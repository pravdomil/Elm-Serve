// klazuka/elm-hot@fb2dc49e9b4fa53b51fa6088a1ac7ffa0b72557a

const fs = require('fs');
const path = require('path');

const hmrCode = "//////////////////// HMR BEGIN ////////////////////\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Original Author: Flux Xu @fluxxu\n*/\n\n/*\n    A note about the environment that this code runs in...\n\n    assumed globals:\n        - `module` (from Node.js module system and webpack)\n\n    assumed in scope after injection into the Elm IIFE:\n        - `scope` (has an 'Elm' property which contains the public Elm API)\n        - various functions defined by Elm which we have to hook such as `_Platform_initialize` and `_Scheduler_binding`\n */\n\nif (module.hot) {\n    (function () {\n        \"use strict\";\n\n        //polyfill for IE: https://github.com/fluxxu/elm-hot-loader/issues/16\n        if (typeof Object.assign != 'function') {\n            Object.assign = function (target) {\n                'use strict';\n                if (target == null) {\n                    throw new TypeError('Cannot convert undefined or null to object');\n                }\n\n                target = Object(target);\n                for (var index = 1; index < arguments.length; index++) {\n                    var source = arguments[index];\n                    if (source != null) {\n                        for (var key in source) {\n                            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                                target[key] = source[key];\n                            }\n                        }\n                    }\n                }\n                return target;\n            };\n        }\n\n        // Elm 0.19.1 introduced a '$' prefix at the beginning of the symbols it emits,\n        // and we check for `Maybe.Just` because we expect it to be present in all Elm programs.\n        var elmVersion;\n        if (typeof elm$core$Maybe$Just !== 'undefined')\n            elmVersion = '0.19.0';\n        else if (typeof $elm$core$Maybe$Just !== 'undefined')\n            elmVersion = '0.19.1';\n        else\n            throw new Error(\"Could not determine Elm version\");\n\n        function elmSymbol(symbol) {\n            try {\n                switch (elmVersion) {\n                    case '0.19.0':\n                        return eval(symbol);\n                    case '0.19.1':\n                        return eval('$' + symbol);\n                    default:\n                        throw new Error('Cannot resolve ' + symbol + '. Elm version unknown!')\n                }\n            } catch (e) {\n                if (e instanceof ReferenceError) {\n                    return undefined;\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        var instances = module.hot.data\n            ? module.hot.data.instances || {}\n            : {};\n        var uid = module.hot.data\n            ? module.hot.data.uid || 0\n            : 0;\n\n        if (Object.keys(instances).length === 0) {\n            log(\"[elm-hot] Enabled\");\n        }\n\n        var cancellers = [];\n\n        // These 2 variables act as dynamically-scoped variables which are set only when the\n        // Elm module's hooked init function is called.\n        var initializingInstance = null;\n        var swappingInstance = null;\n\n        module.hot.accept();\n        module.hot.dispose(function (data) {\n            data.instances = instances;\n            data.uid = uid;\n\n            // Cleanup pending async tasks\n\n            // First, make sure that no new tasks can be started until we finish replacing the code\n            _Scheduler_binding = function () {\n                return _Scheduler_fail(new Error('[elm-hot] Inactive Elm instance.'))\n            };\n\n            // Second, kill pending tasks belonging to the old instance\n            if (cancellers.length) {\n                log('[elm-hot] Killing ' + cancellers.length + ' running processes...');\n                try {\n                    cancellers.forEach(function (cancel) {\n                        cancel();\n                    });\n                } catch (e) {\n                    console.warn('[elm-hot] Kill process error: ' + e.message);\n                }\n            }\n        });\n\n        function log(message) {\n            if (module.hot.verbose) {\n                console.log(message)\n            }\n        }\n\n        function getId() {\n            return ++uid;\n        }\n\n        function findPublicModules(parent, path) {\n            var modules = [];\n            for (var key in parent) {\n                var child = parent[key];\n                var currentPath = path ? path + '.' + key : key;\n                if ('init' in child) {\n                    modules.push({\n                        path: currentPath,\n                        module: child\n                    });\n                } else {\n                    modules = modules.concat(findPublicModules(child, currentPath));\n                }\n            }\n            return modules;\n        }\n\n        function registerInstance(domNode, flags, path, portSubscribes, portSends) {\n            var id = getId();\n\n            var instance = {\n                id: id,\n                path: path,\n                domNode: domNode,\n                flags: flags,\n                portSubscribes: portSubscribes,\n                portSends: portSends,\n                lastState: null // last Elm app state (root model)\n            };\n\n            return instances[id] = instance\n        }\n\n        function isFullscreenApp() {\n            // Returns true if the Elm app will take over the entire DOM body.\n            return typeof elmSymbol(\"elm$browser$Browser$application\") !== 'undefined'\n                || typeof elmSymbol(\"elm$browser$Browser$document\") !== 'undefined';\n        }\n\n        function wrapDomNode(node) {\n            // When embedding an Elm app into a specific DOM node, Elm will replace the provided\n            // DOM node with the Elm app's content. When the Elm app is compiled normally, the\n            // original DOM node is reused (its attributes and content changes, but the object\n            // in memory remains the same). But when compiled using `--debug`, Elm will completely\n            // destroy the original DOM node and instead replace it with 2 brand new nodes: one\n            // for your Elm app's content and the other for the Elm debugger UI. In this case,\n            // if you held a reference to the DOM node provided for embedding, it would be orphaned\n            // after Elm module initialization.\n            //\n            // So in order to make both cases consistent and isolate us from changes in how Elm\n            // does this, we will insert a dummy node to wrap the node for embedding and hold\n            // a reference to the dummy node.\n            //\n            // We will also put a tag on the dummy node so that the Elm developer knows who went\n            // behind their back and rudely put stuff in their DOM.\n            var dummyNode = document.createElement(\"div\");\n            dummyNode.setAttribute(\"data-elm-hot\", \"true\");\n            dummyNode.style.height = \"inherit\";\n            var parentNode = node.parentNode;\n            parentNode.replaceChild(dummyNode, node);\n            dummyNode.appendChild(node);\n            return dummyNode;\n        }\n\n        function wrapPublicModule(path, module) {\n            var originalInit = module.init;\n            if (originalInit) {\n                module.init = function (args) {\n                    var elm;\n                    var portSubscribes = {};\n                    var portSends = {};\n                    var domNode = null;\n                    var flags = null;\n                    if (typeof args !== 'undefined') {\n                        // normal case\n                        domNode = args['node'] && !isFullscreenApp()\n                            ? wrapDomNode(args['node'])\n                            : document.body;\n                        flags = args['flags'];\n                    } else {\n                        // rare case: Elm allows init to be called without any arguments at all\n                        domNode = document.body;\n                        flags = undefined\n                    }\n                    initializingInstance = registerInstance(domNode, flags, path, portSubscribes, portSends);\n                    elm = originalInit(args);\n                    wrapPorts(elm, portSubscribes, portSends);\n                    initializingInstance = null;\n                    return elm;\n                };\n            } else {\n                console.error(\"Could not find a public module to wrap at path \" + path)\n            }\n        }\n\n        function swap(Elm, instance) {\n            log('[elm-hot] Hot-swapping module: ' + instance.path);\n\n            swappingInstance = instance;\n\n            // remove from the DOM everything that had been created by the old Elm app\n            var containerNode = instance.domNode;\n            while (containerNode.lastChild) {\n                containerNode.removeChild(containerNode.lastChild);\n            }\n\n            var m = getAt(instance.path.split('.'), Elm);\n            var elm;\n            if (m) {\n                // prepare to initialize the new Elm module\n                var args = {flags: instance.flags};\n                if (containerNode === document.body) {\n                    // fullscreen case: no additional args needed\n                } else {\n                    // embed case: provide a new node for Elm to use\n                    var nodeForEmbed = document.createElement(\"div\");\n                    containerNode.appendChild(nodeForEmbed);\n                    args['node'] = nodeForEmbed;\n                }\n\n                elm = m.init(args);\n\n                Object.keys(instance.portSubscribes).forEach(function (portName) {\n                    if (portName in elm.ports && 'subscribe' in elm.ports[portName]) {\n                        var handlers = instance.portSubscribes[portName];\n                        if (!handlers.length) {\n                            return;\n                        }\n                        log('[elm-hot] Reconnect ' + handlers.length + ' handler(s) to port \\''\n                            + portName + '\\' (' + instance.path + ').');\n                        handlers.forEach(function (handler) {\n                            elm.ports[portName].subscribe(handler);\n                        });\n                    } else {\n                        delete instance.portSubscribes[portName];\n                        log('[elm-hot] Port was removed: ' + portName);\n                    }\n                });\n\n                Object.keys(instance.portSends).forEach(function (portName) {\n                    if (portName in elm.ports && 'send' in elm.ports[portName]) {\n                        log('[elm-hot] Replace old port send with the new send');\n                        instance.portSends[portName] = elm.ports[portName].send;\n                    } else {\n                        delete instance.portSends[portName];\n                        log('[elm-hot] Port was removed: ' + portName);\n                    }\n                });\n            } else {\n                log('[elm-hot] Module was removed: ' + instance.path);\n            }\n\n            swappingInstance = null;\n        }\n\n        function wrapPorts(elm, portSubscribes, portSends) {\n            var portNames = Object.keys(elm.ports || {});\n            //hook ports\n            if (portNames.length) {\n                // hook outgoing ports\n                portNames\n                    .filter(function (name) {\n                        return 'subscribe' in elm.ports[name];\n                    })\n                    .forEach(function (portName) {\n                        var port = elm.ports[portName];\n                        var subscribe = port.subscribe;\n                        var unsubscribe = port.unsubscribe;\n                        elm.ports[portName] = Object.assign(port, {\n                            subscribe: function (handler) {\n                                log('[elm-hot] ports.' + portName + '.subscribe called.');\n                                if (!portSubscribes[portName]) {\n                                    portSubscribes[portName] = [handler];\n                                } else {\n                                    //TODO handle subscribing to single handler more than once?\n                                    portSubscribes[portName].push(handler);\n                                }\n                                return subscribe.call(port, handler);\n                            },\n                            unsubscribe: function (handler) {\n                                log('[elm-hot] ports.' + portName + '.unsubscribe called.');\n                                var list = portSubscribes[portName];\n                                if (list && list.indexOf(handler) !== -1) {\n                                    list.splice(list.lastIndexOf(handler), 1);\n                                } else {\n                                    console.warn('[elm-hot] ports.' + portName + '.unsubscribe: handler not subscribed');\n                                }\n                                return unsubscribe.call(port, handler);\n                            }\n                        });\n                    });\n\n                // hook incoming ports\n                portNames\n                    .filter(function (name) {\n                        return 'send' in elm.ports[name];\n                    })\n                    .forEach(function (portName) {\n                        var port = elm.ports[portName];\n                        portSends[portName] = port.send;\n                        elm.ports[portName] = Object.assign(port, {\n                            send: function (val) {\n                                return portSends[portName].call(port, val);\n                            }\n                        });\n                    });\n            }\n            return portSubscribes;\n        }\n\n        /*\n        Breadth-first search for a `Browser.Navigation.Key` in the user's app model.\n        Returns the key and keypath or null if not found.\n        */\n        function findNavKey(rootModel) {\n            var queue = [];\n            if (isDebuggerModel(rootModel)) {\n                /*\n                 Extract the user's app model from the Elm Debugger's model. The Elm debugger\n                 can hold multiple references to the user's model (e.g. in its \"history\"). So\n                 we must be careful to only search within the \"state\" part of the Debugger.\n                */\n                queue.push({value: rootModel['state'], keypath: ['state']});\n            } else {\n                queue.push({value: rootModel, keypath: []});\n            }\n\n            while (queue.length !== 0) {\n                var item = queue.shift();\n\n                if (typeof item.value === \"undefined\" || item.value === null) {\n                    continue;\n                }\n\n                // The nav key is identified by a runtime tag added by the elm-hot injector.\n                if (item.value.hasOwnProperty(\"elm-hot-nav-key\")) {\n                    // found it!\n                    return item;\n                }\n\n                if (typeof item.value !== \"object\") {\n                    continue;\n                }\n\n                for (var propName in item.value) {\n                    if (!item.value.hasOwnProperty(propName)) continue;\n                    var newKeypath = item.keypath.slice();\n                    newKeypath.push(propName);\n                    queue.push({value: item.value[propName], keypath: newKeypath})\n                }\n            }\n\n            return null;\n        }\n\n\n        function isDebuggerModel(model) {\n            // Up until elm/browser 1.0.2, the Elm debugger could be identified by a\n            // property named \"expando\". But in version 1.0.2 that was renamed to \"expandoModel\"\n            return model\n                && (model.hasOwnProperty(\"expando\") || model.hasOwnProperty(\"expandoModel\"))\n                && model.hasOwnProperty(\"state\");\n        }\n\n        function getAt(keyPath, obj) {\n            return keyPath.reduce(function (xs, x) {\n                return (xs && xs[x]) ? xs[x] : null\n            }, obj)\n        }\n\n        function removeNavKeyListeners(navKey) {\n            window.removeEventListener('popstate', navKey.value);\n            window.navigator.userAgent.indexOf('Trident') < 0 || window.removeEventListener('hashchange', navKey.value);\n        }\n\n        // hook program creation\n        var initialize = _Platform_initialize;\n        _Platform_initialize = function (flagDecoder, args, init, update, subscriptions, stepperBuilder) {\n            var instance = initializingInstance || swappingInstance;\n            var tryFirstRender = !!swappingInstance;\n\n            var hookedInit = function (args) {\n                var initialStateTuple = init(args);\n                if (swappingInstance) {\n                    var oldModel = swappingInstance.lastState;\n                    var newModel = initialStateTuple.a;\n\n                    if (typeof elmSymbol(\"elm$browser$Browser$application\") !== 'undefined') {\n                        var oldKeyLoc = findNavKey(oldModel);\n\n                        // attempt to find the Browser.Navigation.Key in the newly-constructed model\n                        // and bring it along with the rest of the old data.\n                        var newKeyLoc = findNavKey(newModel);\n                        var error = null;\n                        if (newKeyLoc === null) {\n                            error = \"could not find Browser.Navigation.Key in the new app model\";\n                        } else if (oldKeyLoc === null) {\n                            error = \"could not find Browser.Navigation.Key in the old app model.\";\n                        } else if (newKeyLoc.keypath.toString() !== oldKeyLoc.keypath.toString()) {\n                            error = \"the location of the Browser.Navigation.Key in the model has changed.\";\n                        } else {\n                            // remove event listeners attached to the old nav key\n                            removeNavKeyListeners(oldKeyLoc.value);\n\n                            // insert the new nav key into the old model in the exact same location\n                            var parentKeyPath = oldKeyLoc.keypath.slice(0, -1);\n                            var lastSegment = oldKeyLoc.keypath.slice(-1)[0];\n                            var oldParent = getAt(parentKeyPath, oldModel);\n                            oldParent[lastSegment] = newKeyLoc.value;\n                        }\n\n                        if (error !== null) {\n                            console.error(\"[elm-hot] Hot-swapping \" + instance.path + \" not possible: \" + error);\n                            oldModel = newModel;\n                        }\n                    }\n\n                    // the heart of the app state hot-swap\n                    initialStateTuple.a = oldModel;\n\n                    // ignore any Cmds returned by the init during hot-swap\n                    initialStateTuple.b = elmSymbol(\"elm$core$Platform$Cmd$none\");\n                } else {\n                    // capture the initial state for later\n                    initializingInstance.lastState = initialStateTuple.a;\n                }\n\n                return initialStateTuple\n            };\n\n            var hookedStepperBuilder = function (sendToApp, model) {\n                var result;\n                // first render may fail if shape of model changed too much\n                if (tryFirstRender) {\n                    tryFirstRender = false;\n                    try {\n                        result = stepperBuilder(sendToApp, model)\n                    } catch (e) {\n                        throw new Error('[elm-hot] Hot-swapping ' + instance.path +\n                            ' is not possible, please reload page. Error: ' + e.message)\n                    }\n                } else {\n                    result = stepperBuilder(sendToApp, model)\n                }\n\n                return function (nextModel, isSync) {\n                    if (instance) {\n                        // capture the state after every step so that later we can restore from it during a hot-swap\n                        instance.lastState = nextModel\n                    }\n                    return result(nextModel, isSync)\n                }\n            };\n\n            return initialize(flagDecoder, args, hookedInit, update, subscriptions, hookedStepperBuilder)\n        };\n\n        // hook process creation\n        var originalBinding = _Scheduler_binding;\n        _Scheduler_binding = function (originalCallback) {\n            return originalBinding(function () {\n                // start the scheduled process, which may return a cancellation function.\n                var cancel = originalCallback.apply(this, arguments);\n                if (cancel) {\n                    cancellers.push(cancel);\n                    return function () {\n                        cancellers.splice(cancellers.indexOf(cancel), 1);\n                        return cancel();\n                    };\n                }\n                return cancel;\n            });\n        };\n\n        scope['_elm_hot_loader_init'] = function (Elm) {\n            // swap instances\n            var removedInstances = [];\n            for (var id in instances) {\n                var instance = instances[id];\n                if (instance.domNode.parentNode) {\n                    swap(Elm, instance);\n                } else {\n                    removedInstances.push(id);\n                }\n            }\n\n            removedInstances.forEach(function (id) {\n                delete instance[id];\n            });\n\n            // wrap all public modules\n            var publicModules = findPublicModules(Elm);\n            publicModules.forEach(function (m) {\n                wrapPublicModule(m.path, m.module);\n            });\n        }\n    })();\n\n    scope['_elm_hot_loader_init'](scope['Elm']);\n}\n//////////////////// HMR END ////////////////////"

// inject the HMR code into the Elm compiler's JS output
function inject(originalElmCodeJS) {

    // first, verify that we have not been given Elm 0.18 code
    if (originalElmCodeJS.indexOf("_elm_lang$core$Native_Platform.initialize") >= 0) {
        throw new Error("[elm-hot] Elm 0.18 is not supported. Please use fluxxu/elm-hot-loader@0.5.x instead.");
    }

    let modifiedCode = originalElmCodeJS;

    if (originalElmCodeJS.indexOf("elm$browser$Browser$application") !== -1) {
        // attach a tag to Browser.Navigation.Key values. It's not really fair to call this a hack
        // as this entire project is a hack, but this is evil evil evil. We need to be able to find
        // the Browser.Navigation.Key in a user's model so that we do not swap out the new one for
        // the old. But as currently implemented (2018-08-19), there's no good way to detect it.
        // So we will add a property to the key immediately after it's created so that we can find it.
        const navKeyDefinition = /var\s+key\s*=\s*function\s*\(\)\s*{\s*key.a\(\s*onUrlChange\(\s*_Browser_getUrl\(\)\s*\)\s*\);\s*};/;
        function replacementString(match) {
            return match + "\n" + "key['elm-hot-nav-key'] = true;";
        }
        modifiedCode = originalElmCodeJS.replace(navKeyDefinition, replacementString);
        if (modifiedCode === originalElmCodeJS) {
            throw new Error("[elm-hot] Browser.Navigation.Key def not found. Version mismatch?");
        }
    }

    // splice in the HMR code
    const regex = /(_Platform_export\([^]*)(}\(this\)\);)/;
    const match = regex.exec(modifiedCode);

    if (match === null) {
        throw new Error("Compiled JS from the Elm compiler is not valid. You must use the Elm 0.19 compiler.");
    }

    return modifiedCode.slice(0, match.index)
        + match[1] + "\n\n" + hmrCode + "\n\n" + match[2];
}

module.exports = {
    inject: inject
};